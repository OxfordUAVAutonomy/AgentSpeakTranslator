strm << "/* event-queue, a circular buffer, current_event points to the head */\n";
strm << "static eventt events[MAX_EVENTS];\n";
strm << "static unsigned int events_size;\n";
strm << "static unsigned int current_event;\n";
strm << "\n";
strm << "/* initialise the event queue */\n";
strm << "static void init_events(void)\n";
strm << "{\n";
strm << "  events_size = 0;\n";
strm << "  current_event = 0;\n";
strm << "}\n";
strm << "\n";
strm << "/* add event to event queue at given index */\n";
strm << "static bool add_event(eventt event, unsigned int index)\n";
strm << "{\n";
strm << "  if (events_size < MAX_EVENTS) \n";
strm << "  {\n";
strm << "    /* TODO: add overwrite check? */\n";
strm << "    events[index] = event;\n";
strm << "    events_size = events_size + 1;\n";
strm << "    return true;\n";
strm << "  }\n";
strm << "  /* TODO: what to do in this case? */\n";
strm << "  return false;\n";
strm << "}\n";
strm << "\n";
strm << "/* add event at tail */\n";
strm << "static bool add_event_new_focus(eventt event)\n";
strm << "{\n";
strm << "  unsigned int tail = (current_event + events_size) % MAX_EVENTS;\n";
strm << "  return add_event(event, tail);\n";
strm << "}\n";
strm << "\n";
strm << "/* add event at head */\n";
strm << "static bool add_event_to_complete(eventt event)\n";
strm << "{\n";
strm << "  /* avoid problems with integer division and % */\n";
strm << "  unsigned int head;\n";
strm << "  if (current_event == 0)\n";
strm << "  {\n";
strm << "    head = MAX_EVENTS-1;\n";
strm << "  }\n";
strm << "  else\n";
strm << "  {\n";
strm << "    head = current_event - 1;\n";
strm << "  }\n";
strm << "  if (!add_event(event, head)) \n";
strm << "  {\n";
strm << "    return false;\n";
strm << "  }\n";
strm << "  current_event = head;\n";
strm << "  return true;\n";
strm << "}\n";
strm << "\n";
strm << "/* with an event queue, external events are queued at the back of the event queue */\n";
strm << "bool add_external_event(eventt event)\n";
strm << "{\n";
strm << "  return add_event_new_focus(event);\n";
strm << "}\n";
strm << "\n";
strm << "/* pop next event from event queue (at head) */\n";
strm << "static eventt get_next_event(void)\n";
strm << "{\n";
strm << "  if (events_size <= 0) \n";
strm << "  {\n";
strm << "    eventt nothing = { NONE };\n";
strm << "    return nothing;\n";
strm << "  }\n";
strm << "  eventt event = events[current_event];\n";
strm << "  current_event = (current_event + 1) % MAX_EVENTS;\n";
strm << "  events_size = events_size - 1;\n";
strm << "  return event;\n";
strm << "}\n";
strm << "\n";
strm << "/* indicate whether event queue is full or not */\n";
strm << "bool can_add_event(void)\n";
strm << "{\n";
strm << "  return events_size < MAX_EVENTS;\n";
strm << "}\n";
strm << "\n";
